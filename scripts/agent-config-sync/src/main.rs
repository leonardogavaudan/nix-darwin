use std::env;
use std::fs;
use std::io;
use std::path::{Path, PathBuf};
use std::process;

struct Config {
    source: PathBuf,
    claude_out: PathBuf,
    codex_out: PathBuf,
}

fn main() {
    if let Err(err) = run() {
        eprintln!("error: {err}");
        process::exit(1);
    }
}

fn run() -> Result<(), String> {
    let config = parse_args()?;
    let content = fs::read_to_string(&config.source)
        .map_err(|err| format!("failed to read {}: {err}", config.source.display()))?;

    let shared = extract_section(&content, "SHARED")?;
    let claude = extract_section(&content, "CLAUDE")?;
    let codex = extract_section(&content, "CODEX")?;

    let claude_doc = render_document("CLAUDE.md", &config.source, &shared, &claude);
    let codex_doc = render_document("AGENTS.md", &config.source, &shared, &codex);

    write_file(&config.claude_out, &claude_doc)
        .map_err(|err| format!("failed to write {}: {err}", config.claude_out.display()))?;
    write_file(&config.codex_out, &codex_doc)
        .map_err(|err| format!("failed to write {}: {err}", config.codex_out.display()))?;

    println!("Wrote {}", config.claude_out.display());
    println!("Wrote {}", config.codex_out.display());
    Ok(())
}

fn parse_args() -> Result<Config, String> {
    let home = env::var("HOME").map_err(|_| "HOME is not set".to_string())?;
    let codex_home = env::var("CODEX_HOME").unwrap_or_else(|_| format!("{home}/.config/codex"));
    let mut source = PathBuf::from(format!("{home}/.config/.agents/AGENTS.md"));
    let mut claude_out = PathBuf::from(format!("{home}/.claude/CLAUDE.md"));
    let mut codex_out = PathBuf::from(format!("{codex_home}/AGENTS.md"));

    let mut args = env::args().skip(1);
    while let Some(arg) = args.next() {
        match arg.as_str() {
            "--source" => {
                let value = args
                    .next()
                    .ok_or_else(|| "missing value for --source".to_string())?;
                source = PathBuf::from(value);
            }
            "--claude-out" => {
                let value = args
                    .next()
                    .ok_or_else(|| "missing value for --claude-out".to_string())?;
                claude_out = PathBuf::from(value);
            }
            "--codex-out" => {
                let value = args
                    .next()
                    .ok_or_else(|| "missing value for --codex-out".to_string())?;
                codex_out = PathBuf::from(value);
            }
            "-h" | "--help" => {
                print_help();
                process::exit(0);
            }
            _ => {
                return Err(format!(
                    "unknown argument: {arg}. Run with --help for usage."
                ))
            }
        }
    }

    Ok(Config {
        source,
        claude_out,
        codex_out,
    })
}

fn print_help() {
    println!("agent-config-sync");
    println!();
    println!("Generate agent-specific config files from a canonical AGENTS.md.");
    println!();
    println!("USAGE:");
    println!("  agent-config-sync [--source PATH] [--claude-out PATH] [--codex-out PATH]");
    println!();
    println!("DEFAULTS:");
    println!("  --source     $HOME/.config/.agents/AGENTS.md");
    println!("  --claude-out $HOME/.claude/CLAUDE.md");
    println!("  --codex-out  $CODEX_HOME/AGENTS.md or $HOME/.config/codex/AGENTS.md");
}

fn extract_section(content: &str, name: &str) -> Result<String, String> {
    let start_marker = format!("<!-- BEGIN {name} -->");
    let end_marker = format!("<!-- END {name} -->");

    let start_index = content
        .find(&start_marker)
        .ok_or_else(|| format!("missing marker: {start_marker}"))?;
    let after_start = start_index + start_marker.len();
    let tail = &content[after_start..];
    let end_rel_index = tail
        .find(&end_marker)
        .ok_or_else(|| format!("missing marker: {end_marker}"))?;

    Ok(tail[..end_rel_index].trim_matches('\n').to_string())
}

fn render_document(title: &str, source: &Path, shared: &str, specific: &str) -> String {
    let mut out = String::new();
    out.push_str("# ");
    out.push_str(title);
    out.push_str("\n\n");
    out.push_str("> Generated from `");
    out.push_str(&source.display().to_string());
    out.push_str("` by `agent-config-sync`.\n");
    out.push_str("> Do not edit this file directly; edit the source and re-run the sync tool.\n\n");

    if !shared.is_empty() {
        out.push_str(shared);
        out.push('\n');
    }

    if !specific.is_empty() {
        out.push('\n');
        out.push_str(specific);
        if !specific.ends_with('\n') {
            out.push('\n');
        }
    }

    out
}

fn write_file(path: &Path, content: &str) -> io::Result<()> {
    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent)?;
    }

    let temp_path = path.with_extension("tmp");
    fs::write(&temp_path, content)?;
    fs::rename(temp_path, path)?;
    Ok(())
}
